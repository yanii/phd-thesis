% !TEX root = thesis.tex
\documentclass[thesis]{subfiles}

\begin{document}
	\chapter{Inter-Filter Connectivity}\label{deeproots}
	%Learning Filters with Limited Channel Extents
	\begin{chapquote}{John Denker \etal, \textit{Large Automatic Learning, Complex Systems, 1987}}
		``A general tabula rasa network is a fine subject for the abstract, formal studies, but one should not try to use it to solve practical problems. \ldots One should pre-program the network with all available information about the structure of the problem, especially information about the symmetry and topology of the data.''
	\end{chapquote}
	%It is well understood that the structure of a neural network is critical to its ability to learn from labelled training data and to generalize. Whilst it has been shown that an infinitely wide hidden layer is a universal approximator~\citep{hornik89a}, in practice wide shallow networks do not learn as well as thinner deeper ones --- as shown by recent research~\citep{Krizhevsky2012,Szegedy2014going,Simonyan2014verydeep,He2015}.
	%This does not appear to be a limitation of finite capacity, since it has been proposed that at least some deep networks are by representable by shallow networks~\citep{Ba2013dothey}. Rather it seems to be a consequence of limitations in our methods of learning the weights of deep networks.
	
	With few exceptions, state-of-the-art \glspl{cnn} for image recognition are largely monolithic, with each filter operating on the feature maps of all filters on a previous layer. Interestingly, this is in stark contrast to what we understand of biological neural networks\index{neural network}, where we see ``highly evolved arrangements of smaller, specialized networks which are interconnected in very specific ways''~\citep{minsky1988perceptrons}.
	
	Yet it has been shown that a large proportion of the learned weights in deep networks are redundant~\citep{Denil2013predicting}, a property that has been widely exploited to make neural networks\index{neural network} smaller and more computationally efficient~\citep{Szegedy2014going,Denton2014efficient}. 
	%It is unsurprising then that regularization is a critical part of training such networks using large datasets~\citep{Krizhevsky2012}. Without regularization deep networks are susceptible to over-fitting. Regularization may be achieved by weight decay or dropout~\citep{Hinton2012}. Furthermore
	A carefully designed sparse network connection structure can have a regularizing effect. \Glspl{cnn}~\citep{Fuk80,Lecun1998} embody this idea, using a sparse convolutional connection structure to exploit the locality of natural image structure. In consequence, they are easier to train.
	
	In \cref{lowrankfilters} learning a low-rank spatial basis for filters was found to improve generalization while reducing the computational complexity and model size of a \gls{cnn} with only full rank filters. However, this work addressed only the spatial extents of the convolutional filters (\ie $h$ and $w$ in \cref{fig:normalconv}). In this work we will show that a similar idea can be applied to the channel extents --- \ie filter inter-connectivity --- by using \emph{filter groups}~\citep{Krizhevsky2012}. 
	
	%We show that simple alterations to state-of-the-art \gls{cnn} architectures can drastically reduce computational cost and model size without compromising accuracy.
	
	% Try to find a creative commons version of this
	%\begin{figure}[t]
	%\centering
	%\includegraphics[width=0.25\columnwidth, page=1]{figs/tree_root.jpg}
	%\caption{This work introduces the idea of using hierarchical filter grouping to create \gls{cnn} connection structures that resemble tree roots. Applying the technique to existing state-of-the-art networks allows improved efficiency without compromising accuracy.}
	%\label{fig:tree}
	%\end{figure}
	
	% Maybe we need something like this here too, don't know
	%It has been shown that reducing the co-adaption of filters is beneficial to generalization in deep networks~\citep{Hinton2012,goodfellow2013maxout,Cogswell2016}. Co-adaption occurs when hidden layer filters (or neurons\index{neuron}) rely on one another to fit training data, such that their outputs become highly correlated. However, instead of using a modified loss, regularization penalty, or randomized network connectivity during training to prevent co-adaption of features, we take a much more direct approach. We use hierarchical filter groups (see \cref{regularizingstructure}) to allow the network itself to learn independent filters. By restricting the connectivity between filters on subsequent layers the network is forced to learn filters of limited dependence. We allow the standard network optimization (\eg \gls{sgd}) to learn appropriate weights within this restricted architecture.
	
	In this chapter we show that simple alterations to the architecture of state-of-the-art \glspl{cnn} for image recognition can drastically reduce computational cost and model size while maintaining (or even increasing) accuracy, through structure-induced regularization, by reducing the connectivity in monolithic networks to reflect more closely the sparse, localized filter co-dependencies within.
	
	\section{Related Work}\label{previouswork}
	Most previous work on reducing the computational complexity of \glspl{cnn} has focused on approximating convolutional filters in the spatial (as opposed to the channel) domain, either by using low-rank approximations~\citep{mamalet2012simplifying,journals/corr/JaderbergVZ14, journals/pami/SironiTRLF15, journals/corr/LebedevGROL14, Ioannou2016}, or Fourier transform based convolution~\citep{mathieu2013fast, rippel2015spectral}. More general methods have used reduced precision number representations~\citep{1502.02551v1} or compression of previously trained models~\citep{Chen2015,Kim2016}. Here we explore methods that reduce the computational impact of the large number of filter channels within state-of-the art networks. Specifically, we consider decreasing the number of incoming connections to nodes.
	
	\begin{figure}[tbp]
		\begin{subfigure}[b]{0.95\textwidth}
			\centering
			\includegraphics[width=0.66\textwidth, page=1]{Figs/PDF/groupfig}
			\caption{Convolution}\label{fig:normalconv}
		\end{subfigure}
		~
		\begin{subfigure}[b]{0.95\textwidth}
			\centering
			\includegraphics[width=0.66\textwidth, page=2]{Figs/PDF/groupfig}
			\caption{Convolution with filter groups}\label{fig:groupedconv}
		\end{subfigure}
		\caption[Convolutional filter groups.]{\textbf{Convolutional Filter groups.} (a) Convolutional filters (yellow) typically have the same channel dimension $c_1$ as the input feature maps (gray) on which they operate. However, (b) with filter grouping, $g$ independent groups of $c_2/g$ filters operate on a fraction $c_1/g$ of the input feature map channels, reducing filter dimensions from $h$$\times$$w$$\times$$c_1$ to $h$$\times$$w$$\times$$c_1/g$. This change does not affect the dimensions of the input and output feature maps but significantly reduces computational complexity and the number of model parameters.}\label{fig:groupconfig}
	\end{figure}
	\begin{figure}[tbp]
		\centering
		\pgfplotstableread[col sep=comma]{rootdata/alexnetma.csv}\datatable
		\pgfplotsset{major grid style={dotted,red}}
		
		\begin{tikzpicture}
		\begin{axis}[
		width=0.95\textwidth,
		height=0.33\textheight,
		axis x line=bottom,
		ylabel=Top-5 Val.\ Error,
		xlabel=Model Parameters (\# floats),
		axis lines=left,
		enlarge x limits=0.12,
		enlarge y limits=0.1,
		grid=major,
		%xmin=0,
		ytick={0.01,0.02,...,0.21},
		ymin=0.18,ymax=0.2,
		yticklabel={\pgfmathparse{\tick*100}\pgfmathprintnumber{\pgfmathresult}\%},style={
			/pgf/number format/fixed,
			/pgf/number format/precision=1
		},
		legend style={at={(0.98,0.98)}, anchor=north east, column sep=0.5em},
		legend columns=2,
		]
		\addplot[mark=*,mark options={fill=black},nodes near coords,only marks,
		point meta=explicit symbolic,
		%   x filter/.code={
		%       \ifnum\coordindex>2\def\pgfmathresult{}\fi
		%   },
		] table[meta=Network,x=Param.,y expr={1 - \thisrow{Top-5 Acc.} },]{\datatable};
		%\addplot[mark=square*,mark options={fill=blue},nodes near coords,only marks,
		%   point meta=explicit symbolic,
		%   x filter/.code={
		%       \ifnum\coordindex<3\def\pgfmathresult{}\fi
		%   },
		%] table[meta=Network,x=Param.,y expr={1 - \thisrow{Top-5 Acc.} },]{\datatable};
		%\legend{Standard AlexNet}%, Alternate Filter Grouping}
		\end{axis}
		\end{tikzpicture}
		\caption[AlexNet performance and filter groups.]{\textbf{AlexNet performance and filter groups.} Model Parameters \vs top-5 error for variants of the AlexNet model on \gls{ilsvrc} image classification dataset. Models with moderate numbers of filter groups have far fewer parameters, yet surprisingly maintain comparable error.}\label{fig:alexnetplots}
	\end{figure}
	
	\paragraph{AlexNet Filter groups.} Amongst the seminal contributions made by \citet{Krizhevsky2012}~is the use of `filter groups' in the convolutional layers of a \gls{cnn} (see \cref{fig:groupconfig}). While their use of filter groups was necessitated by the practical need to sub-divide the work of training a large network across multiple \gls{gpu}s, the side effects are somewhat surprising. Specifically, the authors observe that independent filter groups learn a separation of responsibility (colour features \vs{}texture features) that is consistent over different random initializations. Also surprising, and not explicitly stated in~\citep{Krizhevsky2012}, is the fact that the AlexNet network has approximately 57\% fewer connection weights than the corresponding network without filter groups. This is due to the reduction in the input channel dimension of the grouped convolution filters (see \cref{fig:alexnetplots}).
	Despite the large difference in the number of parameters between the models, both achieve comparable accuracy on \gls{ilsvrc} --- in fact the smaller grouped network gets $\approx1$\% lower top-5 validation error. This paper builds upon these findings and extends them to state-of-the-art networks.
	
	\paragraph{Low-dimensional Embeddings.}
	\citet{Lin2013NiN} proposed a method to reduce the dimensionality of convolutional feature maps. 
	By using relatively cheap `1$\times$1' convolutional layers (\ie{}layers comprising $d$ filters of size 1$\times$1$\times$$c$, where $d<c$), they learn to map feature maps into lower-dimensional spaces, \ie to new feature maps with fewer channels. Subsequent spatial filters operating on this lower dimensional input space require significantly less computation. This method is used in most state of the art networks for image classification to reduce computation~\citep{Szegedy2014going,He2015}. Our method is complementary.
	
	\paragraph{GoogLeNet.} In contrast to much other work, \citet{Szegedy2014going} propose a \gls{cnn} architecture that is highly optimized for computational efficiency. GoogLeNet uses, as a basic building block, a mixture of low-dimensional embeddings~\citep{Lin2013NiN} and heterogeneously sized spatial filters --- collectively an `inception' module. 
	There are two distinct forms of convolutional layers in the inception module, low-dimensional embeddings (1$\times$1) and spatial (3$\times$3, 5$\times $5). GoogLeNet keeps large, expensive spatial convolutions (\ie 5$\times$5) to a minimum by using few of these filters, using more 3$\times$3 convolutions, and even more 1$\times$1 filters. The motivation is that most of the convolutional filters respond to localized patterns in a small receptive field, with few requiring a larger receptive field. The number of filters in each successive inception module increases slowly with decreasing feature map size, in order to maintain computational performance. GoogLeNet is by far the most efficient state-of-the-art network for \gls{ilsvrc}, achieving near state-of-the-art accuracy with the lowest computation/model size. However, we will show that even such an efficient and optimized network architecture benefits from our method.
	
	\paragraph{Low-Rank Approximations.}
	Various authors have suggested approximating learned convolutional filters using tensor decomposition~\citep{journals/corr/JaderbergVZ14,journals/corr/LebedevGROL14,Kim2016}. For example, \citet{journals/corr/JaderbergVZ14} propose approximating the convolutional filters in a trained network with representations that are low-rank both in the spatial and the channel domains. This approach significantly decreases computational complexity, albeit at the expense of a small amount of accuracy. In this paper we are not approximating an existing model's weights but creating a new network architecture with explicit structural sparsity, which is then trained from scratch.
	
	\paragraph{Learning a Basis for Filters}
	\begin{figure}[tbp]
		\centering
		\includegraphics[width=0.95\textwidth, page=3]{Figs/PDF/sparsification}
		\caption[Learning a spatial basis for filters.]{\textbf{Learning a spatial basis for filters.} Learning a linear combination of mostly small, heterogeneously sized spatial filters~\citep{Ioannou2016}. Note that all filters operate on all $c$ channels of the input feature map.}
		\label{fig:spatialbasis}
	\end{figure}
	Our approach is connected with that presented in \cref{lowrankfilters}, where we showed that replacing 3$\times$3$\times$c filters with linear combinations of filters with smaller spatial extent (\eg 1$\times$3$\times c$, 3$\times$1$\times c$ filters, see \cref{fig:spatialbasis}) could reduce the model size and computational complexity of state-of-the-art \glspl{cnn}, while maintaining or even increasing accuracy. However, that work did not address the channel extent of the filters.
	\section{Root Architectures}
	\label{method}
	In this section we present the main contribution of our work: the use of novel sparsely connected architectures resembling tree roots --- to decrease computational complexity and model size compared to state-of-the-art deep networks for image recognition.
	
	\paragraph{Learning a Basis for Filter Dependencies}
	It is unlikely that every filter (or neuron\index{neuron}) in a deep neural network\index{neural network} needs to depend on the output of all the filters in the previous layer. In fact, reducing filter co-dependence in deep networks has been shown to benefit generalization. For example, \citet{Hinton2012} introduced {\em dropout} for regularization of deep networks. When training a network layer with dropout, a random subset of neurons\index{neuron} is excluded from both the forward and backward pass for each mini-batch.  Furthermore, \citet{Cogswell2016} observe a correlation between the covariance of hidden unit activations and overfitting. To explicitly reduce the covariance of hidden activations, they train networks with a loss function, based on the covariance matrix of the activations in a hidden layer. 
	
	Instead of using a modified loss, regularization penalty, or randomized network connectivity during training to prevent co-adaption of features, we take a much more direct approach. We use filter groups (see \cref{fig:groupconfig}) to force the network to learn filters with only limited dependence on previous layers. Each of the filters in the filter groups is smaller in the channel extent, since it operates on only a subset of the channels of the input feature map. 
	
	\begin{figure}[tbp]
		\centering
		\begin{subfigure}[b]{0.95\textwidth}
			\centering
			\includegraphics[width=\textwidth, page=4]{Figs/PDF/groupfig}
			\caption{Convolution with $d$ filters of shape $h\times w\times c$.}
			\label{fig:normalresnet}
		\end{subfigure}\\
		\begin{subfigure}[b]{0.95\textwidth}
			\includegraphics[width=\textwidth, page=5]{Figs/PDF/groupfig}
			\caption{Root-2 Module: Convolution with $d$ filters in $g = 2$ filter groups, of shape $h\times w\times c/2$.}
			\label{fig:rootresnet2}
		\end{subfigure}
		\begin{subfigure}[b]{0.95\textwidth}
			\includegraphics[width=\textwidth, page=6]{Figs/PDF/groupfig}
			\caption{Root-4 Module: Convolution with $d$ filters in $g = 4$ filter groups, of shape $h\times w\times c/4$.}
			\label{fig:rootresnet4}
		\end{subfigure}
		\caption[Root modules: learning a channel basis for filters.]{\textbf{Root Modules.} Root modules (b), (c) compared to a typical set of convolutional layers (a) found in ResNet and other modern architectures. Grey blocks represent the feature maps over which a layer's filters operate, while colored blocks represent the filters of each layer. 
		}
		\label{fig:rootmodule}
	\end{figure}
	This reduced connectivity also reduces computational complexity and model size since the size of filters in filter groups are reduced drastically, as is evident in \cref{fig:rootmodule}. Unlike methods for increasing the efficiency of deep networks by approximating pre-trained existing networks (see \cref{previouswork}), our models are trained from random initialization using stochastic gradient descent. This means that our method can also speed up training and, since we are not merely approximating an existing model's weights, the accuracy of the existing model is not an upper bound on accuracy of the modified model.
	
	\paragraph{Root Module}
	The basic element of our network architecture, a \emph{root module}, is shown in \cref{fig:rootmodule}. A root module has a given number of filter groups, the more filter groups, the fewer the number of connections to the previous layer's outputs. Each spatial convolutional layer is followed by a low-dimensional embedding (1$\times$1 convolution). Like in~\citep{Ioannou2016}, this configuration  learns a linear combination of the basis filters (filter groups), implicitly representing a filter of full channel depth, but with limited filter dependence.
	
	\section{Results}
	Here we present image classification results obtained by replacing spatial convolutional layers within existing state-of-the-art network architectures with root modules (described in \cref{method}) .
	
	\subsection{Improving \Gls{nin} on \Gls{cifar10}}
	\Gls{nin}~\citep{Lin2013NiN} is a near state-of-the-art network for \gls{cifar10}~\citep{CIFAR10}. It is composed of 3 spatial (5$\times$5, 3$\times$3) convolutional layers with a large number of filters (192), interspersed with pairs of low-dimensional embedding (1$\times$1) layers. As a baseline, we replicated the standard NiN network architecture as described by \citet{Lin2013NiN} but used state-of-the-art training methods. We trained using random 32$\times$32 cropped and mirrored images from 4-pixel zero-padded  mean-subtracted images, as in~\citep{goodfellow2013maxout, He2015}. We also used the initialization of \citet{He2015b} and batch normalization~\citep{Ioffe2015}. With this configuration, \gls{zca} whitening was not required to reproduce validation accuracies obtained in~\citep{Lin2013NiN}. We also did not use dropout, having found it to have little effect, presumably due to our use of batch normalization, as suggested by \citet{Ioffe2015}.
	
	\begin{table}[tbp]
		\caption[\Gls{nin} root architectures.]{\textbf{\Gls{nin}}. Filter groups in each convolutional layer.}
		\label{table:ninconfig}
		\centering
		%\resizebox{\textwidth}{!}{
		\begin{tabular}{@{}lccccccccc@{}}
			\toprule
			Model & \multicolumn{3}{c}{conv1} & \multicolumn{3}{c}{conv2} & \multicolumn{3}{c}{conv3} \\
			& \textit{\footnotesize a} & \textit{\footnotesize b} & \textit{\footnotesize c} & \textit{\footnotesize a} & \textit{\footnotesize b} & \textit{\footnotesize c} & \textit{\footnotesize a} & \textit{\footnotesize b} & \textit{\footnotesize c} \\
			& \textit{\footnotesize5$\times$5} & \textit{\footnotesize1$\times$1} & \textit{\footnotesize1$\times$1} & \textit{\footnotesize5$\times$5} & \textit{\footnotesize1$\times$1} & \textit{\footnotesize1$\times$1} & \textit{\footnotesize3$\times$3} & \textit{\footnotesize1$\times$1} & \textit{\footnotesize1$\times$1} \\
			Orig. & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1\\
			\midrule
			root-2 & 1 & 1 & 1 & 2 & 1 & 1 & 1 & 1 & 1\\
			root-4 & 1 & 1 & 1 & 4 & 1 & 1 & 2 & 1 & 1\\
			root-8 & 1 & 1 & 1 & 8 & 1 & 1 & 4 & 1 & 1\\
			root-16 & 1 & 1 & 1 & 16 & 1 & 1 & 8 & 1 & 1\\
			\bottomrule
		\end{tabular}
		%}
	\end{table}
	\begin{table}[tp]
		\caption[\Gls{nin} \gls{cifar10} results.]{\textbf{\Gls{nin} \gls{cifar10}}}
		\label{table:nincifarresults}
		\centering
		\pgfplotstableread[col sep=comma]{rootdata/nincifar.csv}\data
		\pgfplotstableread[col sep=comma]{rootdata/nincifar_root_s.csv}\codata
		\pgfplotstableread[col sep=comma]{rootdata/nincifar_tree_s.csv}\tdatatable
		\pgfplotstableread[col sep=comma]{rootdata/nincifar_col_s.csv}\cdatatable
		\pgfplotstablevertcat{\data}{\codata}
		\pgfplotstablevertcat{\data}{\tdatatable}
		\pgfplotstablevertcat{\data}{\cdatatable}
		%\resizebox{\textwidth}{!}{
		\pgfplotstabletypeset[
		every head row/.style={before row=\toprule,after row=\midrule},
		every last row/.style={after row=\bottomrule},
		every row no 0/.style={after row=\midrule}, 
		every nth row={4}{after row=\midrule}, 
		fixed zerofill,     % Fill numbers with zeros
		columns={full name, ma, param, accuracy, cpu, gpu},
		columns/full name/.style={
			column name=Model,
			string type
		},
		columns/ma/.style={
			column name=\gls{flops} {\small $\times 10^{8}$},
			preproc/expr={{##1/1e8}}
		},
		columns/param/.style={
			column name=Param. {\small $\times 10^{5}$},
			preproc/expr={{##1/1e5}}
		},
		columns/accuracy/.style={
			column name=Accuracy,
			precision=4
		},
		columns/gpu/.style={
			column name=\gls{gpu} (ms),
			precision=3
		},
		columns/cpu/.style={
			column name=\gls{cpu} (ms),
			precision=1
		},
		%    column type/.add={@{}lrrrrrr@{}}{},
		column type/.add={@{}lcccccc@{}}{},
		highlight col max ={\data}{accuracy},
		highlight col min ={\data}{param}, 
		highlight col min ={\data}{ma}, 
		col sep=comma]{\data}
		%}
	\end{table}
	To assess the efficacy of our method, we replaced the spatial convolutional layers of the original \gls{nin} network with root modules (as described in \cref{method}). We preserved the original number of filters per layer but subdivided them into groups as shown in \cref{table:ninconfig}. We considered the first of the pair of existing 1$\times$1 layers to be part of our root modules. 
	We did not group filters in the first convolutional layer --- since it operates on the three-channel image space, it is of limited computational impact compared to other layers.
	\begin{figure}[tbp]
		\centering
		\begin{subfigure}[b]{\textwidth}
			\pgfplotstableread[col sep=comma]{rootdata/nincifar.csv}\datatable
			\pgfplotstableread[col sep=comma]{rootdata/nincifar_root_s.csv}\rdatatable
			\pgfplotstableread[col sep=comma]{rootdata/nincifar_tree_s.csv}\tdatatable
			\pgfplotstableread[col sep=comma]{rootdata/nincifar_col_s.csv}\cdatatable
			\pgfplotsset{major grid style={dotted,red}}
			
			\centering
			\begin{tikzpicture}
			%\tikzstyle{every node}=[font=\footnotesize]
			\begin{axis}[
			width=0.95\textwidth,
			height=0.66\textwidth,
			axis x line=bottom,
			ylabel=Error,
			xlabel=Model Parameters,
			axis lines=left,
			enlarge x limits=0.05,
			enlarge y limits=0.05,
			grid=major,
			%xmin=0,
			ytick={0.002,0.004,...,1.0},
			%ymin=0.075,ymax=0.09,
			xticklabel style={
				/pgf/number format/fixed,
				/pgf/number format/precision=1
			},
			yticklabel={\pgfmathparse{\tick*1}\pgfmathprintnumber{\pgfmathresult}\%},style={
				/pgf/number format/fixed zerofill,
				/pgf/number format/precision=1
			},
			legend style={at={(1,1.1)}, anchor=south east, column sep=0.2em, font=\small},
			legend columns=4,
			]
			\addplot[mark=*,mark options={fill=red},
			%nodes near coords,
			only marks,
			point meta=explicit symbolic,
			error bars/y dir=both,
			error bars/y fixed=0.00131497782,
			] table[meta=name,x=param,y expr={1 - \thisrow{accuracy} },]{\datatable};
			\addplot[mark=square*,mark options={fill=green},
			nodes near coords, only marks,
			every node near coord/.append style={inner sep=4pt},
			point meta=explicit symbolic,
			] table[meta=name,x=param,y expr={1 - \thisrow{accuracy} },]{\rdatatable};
			\addplot[mark=triangle*,mark options={fill=blue},
			nodes near coords, nodes near coords align = {below}, only marks,
			every node near coord/.append style={inner sep=4pt},
			point meta=explicit symbolic,
			] table[meta=name,x=param,y expr={1 - \thisrow{accuracy} },]{\tdatatable};
			\addplot[mark=diamond*,mark options={fill=yellow},
			nodes near coords, nodes near coords align = {below}, only marks,
			every node near coord/.append style={inner sep=4pt},
			point meta=explicit symbolic,
			] table[meta=name,x=param,y expr={1 - \thisrow{accuracy} },]{\cdatatable};
			\legend{NiN, Root, Tree, Column}
			\end{axis}
			\end{tikzpicture}
			%\caption{\textbf{Model Parameters \vs Error.}}
			%\label{fig:nincifarparamconvonly}
		\end{subfigure}
		~
		\begin{subfigure}[b]{\textwidth}
			\pgfplotstableread[col sep=comma]{rootdata/nincifar.csv}\datatable
			\pgfplotstableread[col sep=comma]{rootdata/nincifar_root_s.csv}\rdatatable
			\pgfplotstableread[col sep=comma]{rootdata/nincifar_tree_s.csv}\tdatatable
			\pgfplotstableread[col sep=comma]{rootdata/nincifar_col_s.csv}\cdatatable
			\pgfplotsset{major grid style={dotted,red}}
			
			\centering
			\begin{tikzpicture}
			%\tikzstyle{every node}=[font=\footnotesize]
			\begin{axis}[
			width=0.95\textwidth,
			height=0.66\textwidth,
			axis x line=bottom,
			ylabel=Error,
			xlabel=\gls{flops} (Multiply-Add),
			axis lines=left,
			enlarge x limits=0.05,
			enlarge y limits=0.05,
			grid=major,
			%xmin=0,
			ytick={0.002,0.004,...,1.0},
			%ymin=0.075,ymax=0.09,
			xticklabel style={
				/pgf/number format/fixed zerofill,
				/pgf/number format/precision=1
			},
			yticklabel={\pgfmathparse{\tick*1}\pgfmathprintnumber{\pgfmathresult}\%},style={
				/pgf/number format/fixed zerofill,
				/pgf/number format/precision=1
			},
			]
			\addplot[mark=*,mark options={fill=red},
			%nodes near coords,
			only marks,
			point meta=explicit symbolic,
			error bars/y dir=both,
			error bars/y fixed=0.00131497782,
			] table[meta=name,x=ma,y expr={1 - \thisrow{accuracy} },]{\datatable};
			\addplot[mark=square*,mark options={fill=green},
			nodes near coords, only marks,
			every node near coord/.append style={inner sep=4pt},
			point meta=explicit symbolic,
			] table[meta=name,x=ma,y expr={1 - \thisrow{accuracy} },]{\rdatatable};
			\addplot[mark=triangle*,mark options={fill=blue},
			nodes near coords, nodes near coords align = {below}, only marks,
			every node near coord/.append style={inner sep=4pt},
			point meta=explicit symbolic,
			] table[meta=name,x=ma,y expr={1 - \thisrow{accuracy} },]{\tdatatable};
			\addplot[mark=diamond*,mark options={fill=yellow},
			nodes near coords, nodes near coords align = {below}, only marks,
			every node near coord/.append style={inner sep=4pt},
			point meta=explicit symbolic,
			] table[meta=name,x=ma,y expr={1 - \thisrow{accuracy} },]{\cdatatable};
			\end{axis}
			\end{tikzpicture}
			%\caption{\textbf{\gls{flops} (Multiply-Add) \vs Error.}}
			%\label{fig:nincifarmaconvonly}
		\end{subfigure}
		
		\caption[\Gls{nin} \gls{cifar10} results.]{\textbf{\Gls{nin} \gls{cifar10} Results.} Spatial filters (3$\times$3, 5$\times$5) are grouped hierarchically. The best models are closest to the origin. For the standard network, the mean and standard deviation (error bars) are shown over 5 different random initializations.
			%(left) Parameters \vs Error, (right) \gls{flops} \vs Error.
		}\label{fig:nincifarplotsconvonly}
	\end{figure}
	Results are shown in \cref{table:nincifarresults} and \cref{fig:nincifarplotsconvonly} for various network architectures\footnote{Here (and subsequently unless stated otherwise) timings are per image for a forward pass computed on a large batch. Networks were implemented using Caffe (with CuDNN and MKL) and run on an Nvidia Titan Z \gls{gpu} and 2 10-core Intel Xeon E5-2680 v2 \gls{cpu}s.}. Compared to the baseline architecture, the root variants achieve a significant reduction in computation and model size without a significant reduction in accuracy. For example, the root-8 architecture gives equivalent accuracy with only 46\% of the \gls{flops}, 33\% of the model parameters of the original network, and approximately 37\% and 23\% faster \gls{cpu} and \gls{gpu} timings (see \cref{gpuexplanation} for an explanation of the \gls{gpu} timing disparity).
	
	\newcommand{\covarlabels}[5]{%
		\begin{tikzpicture}[anchor=south west]
		\node [inner sep=0pt] (c)
		{
			#5
		};
		\ifx\covarwidth\undefined
		\newlength{\covarwidth}
		\newlength{\covarheight}
		\fi
		\settowidth{\covarwidth}{#5}
		\settoheight{\covarheight}{#5}
		\path[use as bounding box] (c.south west) rectangle (c.north east);
		\node [anchor=south west, xshift=-0.5em, yshift=-0.5em, rotate=45] at (c.north west) {\footnotesize 0};
		\node [anchor=south east, xshift=\covarwidth, yshift=-0.2em] at (c.north west) {\footnotesize #4};
		\node [anchor=south west, xshift=0.25em, yshift=-1.05\covarheight, rotate=90] at (c.north west) {\footnotesize #2};
		\node [anchor=south, xshift=0.5\covarwidth] at (c.north west) {\footnotesize\texttt{#3}};
		\node [anchor=south, xshift=0.2em, yshift=-0.5\covarheight, rotate=90] at (c.north west) {\footnotesize \texttt{#1}};
		\end{tikzpicture}%
	}
	
	%\afterpage{
	%\begin{landscape}
		\begin{figure}[p]
			\centering
			\begin{subfigure}[b]{0.3\textheight}
				\centering
				\covarlabels{conv2c}{192}{conv3a}{192}{\includegraphics[width=\textwidth]{Figs/PDF/msrc-cifar-nin-4pad-conv8-corr}}
				\caption{Standard}\label{fig:normalcovartestfull}
			\end{subfigure}
			\hspace{1em}
			\begin{subfigure}[b]{0.3\textheight}
				\centering
				\covarlabels{conv2c}{192}{conv3a}{192}{\includegraphics[width=\textwidth]{Figs/PDF/msrc-cifar-nin-4pad-funnel2-convonly-conv8-corr}}
				\caption{Root-2 (1 group)}\label{fig:root2corrfull}
			\end{subfigure}
			\hspace{1em}
			\begin{subfigure}[b]{0.3\textheight}
				\centering
				\covarlabels{conv2c}{192}{conv3a}{192}{\includegraphics[width=\textwidth]{Figs/PDF/msrc-cifar-nin-4pad-funnel4-convonly-conv8-corr}}
				\caption{Root-4 (2 groups)}\label{fig:root4corrfull}
			\end{subfigure}
			\hspace{1em}
			\begin{subfigure}[b]{0.3\textheight}
				\centering
				\vspace*{0.6em}
				\covarlabels{conv2c}{192}{conv3a}{192}{\includegraphics[width=\textwidth]{Figs/PDF/msrc-cifar-nin-4pad-funnel8-convonly-conv8-corr}}
				\caption{Root-8 (4 groups)}\label{fig:root8corrfull}
			\end{subfigure}
			\hspace{1em}
			\begin{subfigure}[b]{0.3\textheight}
				\centering
				\vspace*{0.6em}
				\covarlabels{conv2c}{192}{conv3a}{192}{\includegraphics[width=\textwidth]{Figs/PDF/msrc-cifar-nin-4pad-funnel16-convonly-conv8-corr}}
				\caption{Root-16 (8 groups)}\label{fig:root16corrfull}
			\end{subfigure}
			\hspace{1em}
			\begin{subfigure}[b]{0.3\textheight}
				\centering
				\vspace*{0.6em}
				\covarlabels{conv2c}{192}{conv3a}{192}{\includegraphics[width=\textwidth]{Figs/PDF/msrc-cifar-nin-4pad-funnel32-convonly-conv8-corr}}
				\caption{Root-32}\label{fig:root32corrfull}
			\end{subfigure}
			\caption[Inter-layer filter covariance conv2c--conv3a.]{\textbf{Inter-layer filter covariance conv2c--conv3a.} The block-diagonal sparsity learned by a root-unit is visible in the correlation of filters on layers \texttt{conv3a} and \texttt{conv2c} in the NiN network.}\label{fig:covar}
		\end{figure}
	%\end{landscape}}
	
	\Cref{fig:covar} shows the inter-layer correlation between the adjacent filter layers \texttt{conv2c} and \texttt{conv3a} in the network architectures outlined in \cref{table:ninconfig} as evaluated on the CIFAR test set. The block-diagonalization enforced by the filter group structure (as illustrated in \cref{fig:groupconfig}) is visible, more so with larger number of filter groups. This shows that the network learns an organization of filters such that the sparsely distributed strong filter relations, visible in \cref{fig:normalcovartestfull} as brighter pixels, are grouped into a denser block-diagonal structure, leaving a visibly darker, low-correlated background.
	
	\subsection{Inter-Layer Covariance}
	\label{interlayercovar}
	To show the relationships between filters between adjacent convolutional layers, as illustrated in \cref{fig:normalconv}, we calculate the covariance of the responses from two adjacent featuremaps, the outputs of convolutional layers with $c_1$ and $c_2$ filters.
	
	Let $X_i = [\mathbf{x}_{i,1}; \mathbf{x}_{i,2}; \ldots ; \mathbf{x}_{i,N}]$ be the matrix of $N$ samples $\mathbf{x}_{i,n}$ from the $c_i$ dimensional featuremap for layer $i$. We consider each pixel across the two featuremaps to be a sample, and thus each vector $\mathbf{x}_{i,n}$ is a single pixel filter response of dimension $c_i$. If two featuremaps have different spatial dimensions, due to pooling, we up-sample the smaller featuremap (with nearest neighbor interpolation) such that there are the same number of pixels (and thus samples) in each featuremap.
	
	Given two samples $X_1, X_2$ with zero mean (\ie mean subtracted) for two adjacent featuremaps, we calculate the inter-layer covariance,
	
	\begin{align}
	cov(X_1, X_2) &= E\left[X_1\,X_2^\textrm{T}\right],\\
	&= \frac{1}{N-1} X_1\,X_2^\textrm{T}.
	\end{align}
	
	\begin{figure}[tbp]
		\centering
		\begin{subfigure}[b]{0.3\textheight}
			\centering
			\covarlabels{conv2c}{192}{conv3a}{192}{\includegraphics[width=\textwidth]{Figs/Raster/ninroot32/layercovar_conv8}}
			\caption{Non-whitened responses}
			\label{fig:notwhitened}
		\end{subfigure}
		\hspace{1em}
		\begin{subfigure}[b]{0.3\textheight}
			\centering
			\covarlabels{conv2c}{192}{conv3a}{192}{\includegraphics[width=\textwidth]{Figs/Raster/ninroot32/layercovarwhite_conv8}}
			\caption{Whitened responses}
			\label{fig:whitened}
		\end{subfigure}
		\caption[Inter-layer covariance with/without whitened responses.]{Covariance for between two layers in the root-32 \gls{nin} model with and without whitened responses.}
		\label{fig:whitevsnot}
	\end{figure}
	
	While this shows the covariance between layers, it is conflated with the inherent covariances within $X_1$ and $X_2$ from the data (as shown in \cref{fig:notwhitened}). We can more clearly show the covariance between layers by first whitening (using \gls{zca}~\citep{CIFAR10}) the samples in $X_1$ and $X_2$. For a covariance matrix,
	
	\begin{equation}
	cov(X, X) = \frac{1}{N-1} XX^\textrm{T},
	\end{equation}
	
	The \gls{zca} whitening transformation is given by,
	\begin{equation}
	W = \sqrt{N-1}\left(XX^\textrm{T}\right)^{-\frac{1}{2}}.
	\end{equation}
	
	Since the covariance matrix is symmetric, it is easily diagonalizable (\ie \gls{pca}),
	\begin{align}
	cov(X, X) &= \frac{1}{N-1} XX^\textrm{T},\\
	&=\frac{1}{N-1} PDP^\textrm{T},\\
	\end{align}
	where $P$ is a orthogonal matrix and $D$ a diagonal matrix. This diagonalization allows a simplified calculation of the whitening transformation (see the derivation in Appendix A of \citet{CIFAR10}),
	
	\begin{equation}
	W = \sqrt{N-1}PD^{-\frac{1}{2}}P^\textrm{T},
	\end{equation}
	where $D^{-\frac{1}{2}}$ is simply D with an element-wise power of $-\frac{1}{2}$.
	
	The covariance between the whitened featuremap responses is then,
	\begin{equation}
	cov(W_1 X_1, W_2 X_2) = E\left[(W_1X_1)\,(W_2X_2)^\textrm{T}\right].
	\end{equation}
	\afterpage{%
	    \begin{landscape}
			\begin{figure}[p]
				\begin{subfigure}[c]{0.97\linewidth}
					\centering
    				\vspace{0.6em}
					\covarlabels{conv1a}{192}{conv1a}{192}{\includegraphics[width=0.11\linewidth]{Figs/Raster/nin/corrcoef_conv0}}
					~
					\covarlabels{conv1b}{160}{conv1b}{160}{\includegraphics[width=0.11\linewidth]{Figs/Raster/nin/corrcoef_conv1}}
					~
					\covarlabels{conv1c}{96}{conv1c}{96}{\includegraphics[width=0.11\linewidth]{Figs/Raster/nin/corrcoef_conv2}}
					~
					\covarlabels{conv2a}{192}{conv2a}{192}{\includegraphics[width=0.11\linewidth]{Figs/Raster/nin/corrcoef_conv4}}
					~
					\covarlabels{conv2b}{192}{conv2b}{192}{\includegraphics[width=0.11\linewidth]{Figs/Raster/nin/corrcoef_conv5}}
					~
					\covarlabels{conv2c}{192}{conv2c}{192}{\includegraphics[width=0.11\linewidth]{Figs/Raster/nin/corrcoef_conv6}}
					~
					\covarlabels{conv3a}{192}{conv3a}{192}{\includegraphics[width=0.11\linewidth]{Figs/Raster/nin/corrcoef_conv8}}
					~
					\covarlabels{conv3b}{192}{conv3b}{192}{\includegraphics[width=0.11\linewidth]{Figs/Raster/nin/corrcoef_conv9}}
					\caption{\Gls{nin}}\label{fig:corrroot1}
    				\vspace{0.6em}
				\end{subfigure}\\
				\begin{subfigure}[c]{0.97\linewidth}
					\centering
    				\vspace{0.6em}
					\covarlabels{conv1a}{192}{conv1a}{192}{\includegraphics[width=0.11\linewidth]{Figs/Raster/ninroot4/corrcoef_conv0}}
					~
					\covarlabels{conv1b}{160}{conv1b}{160}{\includegraphics[width=0.11\linewidth]{Figs/Raster/ninroot4/corrcoef_conv1}}
					~
					\covarlabels{conv1c}{96}{conv1c}{96}{\includegraphics[width=0.11\linewidth]{Figs/Raster/ninroot4/corrcoef_conv2}}
					~
					\covarlabels{conv2a}{192}{conv2a}{192}{\includegraphics[width=0.11\linewidth]{Figs/Raster/ninroot4/corrcoef_conv4}}
					~
					\covarlabels{conv2b}{192}{conv2b}{192}{\includegraphics[width=0.11\linewidth]{Figs/Raster/ninroot4/corrcoef_conv5}}
					~
					\covarlabels{conv2c}{192}{conv2c}{192}{\includegraphics[width=0.11\linewidth]{Figs/Raster/ninroot4/corrcoef_conv6}}
					~
					\covarlabels{conv3a}{192}{conv3a}{192}{\includegraphics[width=0.11\linewidth]{Figs/Raster/ninroot4/corrcoef_conv8}}
					~
					\covarlabels{conv3b}{192}{conv3b}{192}{\includegraphics[width=0.11\linewidth]{Figs/Raster/ninroot4/corrcoef_conv9}}
					\caption{Root-4}\label{fig:corrroot4}
					\vspace*{0.6em}
				\end{subfigure}\\
				\begin{subfigure}[c]{0.97\linewidth}
					\centering
    				\vspace{0.6em}
					\covarlabels{conv1a}{192}{conv1a}{192}{\includegraphics[width=0.11\linewidth]{Figs/Raster/ninroot8/corrcoef_conv0}}
					~
					\covarlabels{conv1b}{160}{conv1b}{160}{\includegraphics[width=0.11\linewidth]{Figs/Raster/ninroot8/corrcoef_conv1}}
					~
					\covarlabels{conv1c}{96}{conv1c}{96}{\includegraphics[width=0.11\linewidth]{Figs/Raster/ninroot8/corrcoef_conv2}}
					~
					\covarlabels{conv2a}{192}{conv2a}{192}{\includegraphics[width=0.11\linewidth]{Figs/Raster/ninroot8/corrcoef_conv4}}
					~
					\covarlabels{conv2b}{192}{conv2b}{192}{\includegraphics[width=0.11\linewidth]{Figs/Raster/ninroot8/corrcoef_conv5}}
					~
					\covarlabels{conv2c}{192}{conv2c}{192}{\includegraphics[width=0.11\linewidth]{Figs/Raster/ninroot8/corrcoef_conv6}}
					~
					\covarlabels{conv3a}{192}{conv3a}{192}{\includegraphics[width=0.11\linewidth]{Figs/Raster/ninroot8/corrcoef_conv8}}
					~
					\covarlabels{conv3b}{192}{conv3b}{192}{\includegraphics[width=0.11\linewidth]{Figs/Raster/ninroot8/corrcoef_conv9}}
					\caption{Root-8}\label{fig:corrroot8}
					\vspace*{0.6em}
				\end{subfigure}\\
				\begin{subfigure}[c]{0.97\linewidth}
					\centering
    				\vspace{0.6em}
					\covarlabels{conv1a}{192}{conv1a}{192}{\includegraphics[width=0.11\linewidth]{Figs/Raster/ninroot32/corrcoef_conv0}}
					~
					\covarlabels{conv1b}{160}{conv1b}{160}{\includegraphics[width=0.11\linewidth]{Figs/Raster/ninroot32/corrcoef_conv1}}
					~
					\covarlabels{conv1c}{96}{conv1c}{96}{\includegraphics[width=0.11\linewidth]{Figs/Raster/ninroot32/corrcoef_conv2}}
					~
					\covarlabels{conv2a}{192}{conv2a}{192}{\includegraphics[width=0.11\linewidth]{Figs/Raster/ninroot32/corrcoef_conv4}}
					~
					\covarlabels{conv2b}{192}{conv2b}{192}{\includegraphics[width=0.11\linewidth]{Figs/Raster/ninroot32/corrcoef_conv5}}
					~
					\covarlabels{conv2c}{192}{conv2c}{192}{\includegraphics[width=0.11\linewidth]{Figs/Raster/ninroot32/corrcoef_conv6}}
					~
					\covarlabels{conv3a}{192}{conv3a}{192}{\includegraphics[width=0.11\linewidth]{Figs/Raster/ninroot32/corrcoef_conv8}}
					~
					\covarlabels{conv3b}{192}{conv3b}{192}{\includegraphics[width=0.11\linewidth]{Figs/Raster/ninroot32/corrcoef_conv9}}
					\caption{Root-32}\label{fig:corrroot32}
					\vspace*{0.6em}
				\end{subfigure}\\
				\begin{subfigure}[c]{0.97\linewidth}
    				\centering
	    			\includegraphics[width=0.4\linewidth]{Figs/PDF/colorbar}
				\end{subfigure}
				\caption[Intra-layer filter correlation.]{\textbf{\Gls{nin} Intra-Layer Correlation.} Absolute Correlation of filters within each layer of a NiN model variant.}
				\label{fig:nincorr}
			\end{figure}
		\end{landscape}
		\begin{landscape}
			\begin{figure}[p]
				\begin{subfigure}[c]{0.95\linewidth}
					\centering
					\covarlabels{conv1a}{192}{conv1b}{160}{\includegraphics[width=0.1\linewidth]{Figs/Raster/nin/layercovarwhite_conv1}}
					~
					\covarlabels{conv1b}{160}{conv1c}{96}{\includegraphics[width=0.05\linewidth]{Figs/Raster/nin/layercovarwhite_conv2}}
					~
					\covarlabels{conv1c}{96}{conv2a}{192}{\includegraphics[width=0.12\linewidth]{Figs/Raster/nin/layercovarwhite_conv4}}
					~
					\covarlabels{conv2a}{192}{conv2b}{192}{\includegraphics[width=0.12\linewidth]{Figs/Raster/nin/layercovarwhite_conv5}}
					~
					\covarlabels{conv2b}{192}{conv2c}{192}{\includegraphics[width=0.12\linewidth]{Figs/Raster/nin/layercovarwhite_conv6}}
					~
					\covarlabels{conv2c}{192}{conv3a}{192}{\includegraphics[width=0.12\linewidth]{Figs/Raster/nin/layercovarwhite_conv8}}
					~
					\covarlabels{conv3a}{192}{conv3b}{192}{\includegraphics[width=0.12\linewidth]{Figs/Raster/nin/layercovarwhite_conv9}}
					~
					\covarlabels{}{192}{}{10}{\includegraphics[width=0.00624996\linewidth]{Figs/Raster/nin/layercovarwhite_conv10}}
					\caption{\Gls{nin}}
					\vspace*{0.6em}
					\label{fig:covaroot1}
				\end{subfigure}
				~
				\begin{subfigure}[c]{0.95\linewidth}
					\centering
					\covarlabels{conv1a}{192}{conv1b}{160}{\includegraphics[width=0.1\linewidth]{Figs/Raster/ninroot4/layercovarwhite_conv1}}
					~
					\covarlabels{conv1b}{160}{conv1c}{96}{\includegraphics[width=0.05\linewidth]{Figs/Raster/ninroot4/layercovarwhite_conv2}}
					~
					\covarlabels{conv1c}{96}{conv2a}{192}{\includegraphics[width=0.12\linewidth]{Figs/Raster/ninroot4/layercovarwhite_conv4}}
					~
					\covarlabels{conv2a}{192}{conv2b}{192}{\includegraphics[width=0.12\linewidth]{Figs/Raster/ninroot4/layercovarwhite_conv5}}
					~
					\covarlabels{conv2b}{192}{conv2c}{192}{\includegraphics[width=0.12\linewidth]{Figs/Raster/ninroot4/layercovarwhite_conv6}}
					~
					\covarlabels{conv2c}{192}{conv3a}{192}{\includegraphics[width=0.12\linewidth]{Figs/Raster/ninroot4/layercovarwhite_conv8}}
					~
					\covarlabels{conv3a}{192}{conv3b}{192}{\includegraphics[width=0.12\linewidth]{Figs/Raster/ninroot4/layercovarwhite_conv9}}
					~
					\covarlabels{}{192}{}{10}{\includegraphics[width=0.00624996\linewidth]{Figs/Raster/ninroot4/layercovarwhite_conv10}}
					\caption{Root-4}
					\vspace*{0.6em}
					\label{fig:covarroot4}
				\end{subfigure}
				\begin{subfigure}[c]{0.95\linewidth}
					\centering
					\covarlabels{conv1a}{192}{conv1b}{160}{\includegraphics[width=0.1\linewidth]{Figs/Raster/ninroot8/layercovarwhite_conv1}}
					~
					\covarlabels{conv1b}{160}{conv1c}{96}{\includegraphics[width=0.05\linewidth]{Figs/Raster/ninroot8/layercovarwhite_conv2}}
					~
					\covarlabels{conv1c}{96}{conv2a}{192}{\includegraphics[width=0.12\linewidth]{Figs/Raster/ninroot8/layercovarwhite_conv4}}
					~
					\covarlabels{conv2a}{192}{conv2b}{192}{\includegraphics[width=0.12\linewidth]{Figs/Raster/ninroot8/layercovarwhite_conv5}}
					~
					\covarlabels{conv2b}{192}{conv2c}{192}{\includegraphics[width=0.12\linewidth]{Figs/Raster/ninroot8/layercovarwhite_conv6}}
					~
					\covarlabels{conv2c}{192}{conv3a}{192}{\includegraphics[width=0.12\linewidth]{Figs/Raster/ninroot8/layercovarwhite_conv8}}
					~
					\covarlabels{conv3a}{192}{conv3b}{192}{\includegraphics[width=0.12\linewidth]{Figs/Raster/ninroot8/layercovarwhite_conv9}}
					~
					\covarlabels{}{192}{}{10}{\includegraphics[width=0.00624996\linewidth]{Figs/Raster/ninroot8/layercovarwhite_conv10}}
					\caption{Root-8}
					\vspace*{0.6em}
					\label{fig:covarroot8}
				\end{subfigure}
				\begin{subfigure}[c]{0.95\linewidth}
					\centering
					\covarlabels{conv1a}{192}{conv1b}{160}{\includegraphics[width=0.1\linewidth]{Figs/Raster/ninroot32/layercovarwhite_conv1}}
					~
					\covarlabels{conv1b}{160}{conv1c}{96}{\includegraphics[width=0.05\linewidth]{Figs/Raster/ninroot32/layercovarwhite_conv2}}
					~
					\covarlabels{conv1c}{96}{conv2a}{192}{\includegraphics[width=0.12\linewidth]{Figs/Raster/ninroot32/layercovarwhite_conv4}}
					~
					\covarlabels{conv2a}{192}{conv2b}{192}{\includegraphics[width=0.12\linewidth]{Figs/Raster/ninroot32/layercovarwhite_conv5}}
					~
					\covarlabels{conv2b}{192}{conv2c}{192}{\includegraphics[width=0.12\linewidth]{Figs/Raster/ninroot32/layercovarwhite_conv6}}
					~
					\covarlabels{conv2c}{192}{conv3a}{192}{\includegraphics[width=0.12\linewidth]{Figs/Raster/ninroot32/layercovarwhite_conv8}}
					~
					\covarlabels{conv3a}{192}{conv3b}{192}{\includegraphics[width=0.12\linewidth]{Figs/Raster/ninroot32/layercovarwhite_conv9}}
					~
					\covarlabels{}{192}{}{10}{\includegraphics[width=0.00624996\linewidth]{Figs/Raster/ninroot32/layercovarwhite_conv10}}
					\caption{Root-32}
					\label{fig:covarroot32}
				\end{subfigure}
				\caption[Inter-layer covariance (all layers).]{\textbf{\Gls{nin} Inter-layer Absolute Covariance.} The inter-layer covariance for all layers in variants of the NiN network.}
				\label{fig:suppcovariances}
			\end{figure}
		\end{landscape}
	}%afterpage
	
	\Cref{fig:nincorr} shows the per-layer (intra-layer) filter correlation. This shows the correlation of filters is more structured in root-networks, filters are learned to be linearly combined into useful filters by the root module, and thus filters are often grouped together with other filters they correlate strongly with.
	
	\Cref{fig:covar} shows the inter-layer filter covariances between layers \texttt{conv3a} and \texttt{conv2c}. \Cref{fig:suppcovariances} shows the full set of inter-layer covariances between all convolutional layers in the NiN models. Block-diagonal sparsity is visible on the layers with filter groups, \texttt{conv2a} and \texttt{conv3a}. This block-diagonal is shown for all variants in more detail in \cref{fig:suppcovariances}.
	
	\subsection{Grouping Degree with Network Depth}
	\afterpage{
	\begin{landscape}
	\begin{figure}[p]
		\begin{subfigure}[b]{0.98\linewidth}
			\centering
			\begin{tikzpicture}[ampersand replacement=\&]
			\begin{scope}[]
			\matrix[column sep=0em]{
				\node (1a) {
					\raisebox{-0.5\height}{\includegraphics[height=0.065\linewidth, page=15]{groupfig}}
				};\&
				\node (1b) {
					\raisebox{-0.5\height}{\includegraphics[height=0.095\linewidth, page=17]{groupfig}}
				};\&
				\node (1c) {
					\raisebox{-0.5\height}{\includegraphics[height=0.095\linewidth, page=17]{groupfig}}
				};\&
				\node (2a) {
					\raisebox{-0.5\height}{\includegraphics[height=0.075\linewidth, page=16]{groupfig}}
				};\&
				\node (2b) {
					\raisebox{-0.5\height}{\includegraphics[height=0.095\linewidth, page=17]{groupfig}}
				};\&
				\node (2c) {
					\raisebox{-0.5\height}{\includegraphics[height=0.095\linewidth, page=17]{groupfig}}
				};\&
				\node (3a) {
					\raisebox{-0.5\height}{\includegraphics[height=0.075\linewidth, page=16]{groupfig}}
				};\&
				\node (3b) {
					\raisebox{-0.5\height}{\includegraphics[height=0.095\linewidth, page=17]{groupfig}}
				};\&
				\node (3c) {
					\raisebox{-0.5\height}{\includegraphics[height=0.095\linewidth, page=17]{groupfig}}
				};\&
				\node (7) {
					{\large $\cdots$}
				};\\
				\draw node{{\footnotesize \textit{image}}/{\footnotesize \textit{conv1a}}};\&
				\draw node{\footnotesize \textit{conv1b}};\&
				\draw node{\footnotesize \textit{conv1c}};\&
				\draw node{\footnotesize \textit{conv2a}};\&
				\draw node{\footnotesize \textit{conv2b}};\&
				\draw node{\footnotesize \textit{conv2c}};\&
				\draw node{\footnotesize \textit{conv3a}};\&
				\draw node{\footnotesize \textit{conv3b}};\&
				\draw node{\footnotesize \textit{conv3c}};\\
			};
			\end{scope}
			\end{tikzpicture}
			\caption{Standard}
			\label{fig:standardtopology}
		\end{subfigure}\\
		\begin{subfigure}[b]{0.98\linewidth}
			\centering
			\begin{tikzpicture}[ampersand replacement=\&]
			\begin{scope}[]
			\matrix[column sep=0em]{
				\node (1a) {
					\includegraphics[height=0.065\linewidth, page=15]{groupfig}
				};\&
				\node (1b) {
					\includegraphics[height=0.095\linewidth, page=17]{groupfig}
				};\& 
				\node (1c) {
					\includegraphics[height=0.095\linewidth, page=17]{groupfig}
				};\& 
				\node (2a) {
					\includegraphics[height=0.13\linewidth, page=19]{groupfig}
				};\&
				\node (2b) {
					\includegraphics[height=0.095\linewidth, page=17]{groupfig}
				};\&
				\node (2c) {
					\includegraphics[height=0.095\linewidth, page=17]{groupfig}
				};\&
				\node (3a) {
					\includegraphics[height=0.075\linewidth, page=18]{groupfig}
				};\&
				\node (3b) {
					\includegraphics[height=0.095\linewidth, page=17]{groupfig}
				};\&
				\node (3c) {
					\includegraphics[height=0.095\linewidth, page=17]{groupfig}
				};\&
				\node (4) {
					{\large $\cdots$}
				};\\
			};
			\draw[decorate,decoration={brace,mirror},](2a.south west) -- node[below=3pt] {\small root-4 module} ++(3.5, 0);
			\draw[decorate,decoration={brace,mirror},yshift=-2em](3a.south west) + (0, -0.5) -- node[below=3pt] {\small root-2 module} ++(3.5, -0.5);
			\end{scope}
			\end{tikzpicture}
			\caption{Root-4 Architecture}
			\label{fig:root4topology}
		\end{subfigure}
		\caption[\Gls{nin} standard \vs root architecture.]{\textbf{\Gls{nin} Root Architecture.} The Root-4 architecture as compared to the original architecture for all the convolutional layers. Colored blocks represent the filters of each layer. Here we don't show the intermediate feature maps over which a layer's filters operate, or the final fully connected layer, out of space considerations (see \cref{fig:networkinnetwork,fig:rootmodule}). The decreasing degree of grouping in successive root modules means that our network architectures somewhat resemble plant roots, hence the name root.
		}\label{fig:networktopology}
	\end{figure}
	\end{landscape}
	}
	An interesting question concerns how the degree of grouping in our root modules should be varied as a function of depth in the network. For the \gls{nin}-like architectures described earlier, we might consider having the degree of grouping: (1) decrease with depth after the first convolutional layer, \eg 1--8--4 (`root'); (2) remain constant with depth after the first convolutional layer, \eg 1--4--4 (`column'); or (3) increase with depth, \eg 1--4--8 (`tree').
	
	To determine which approach is best, we created variants of the NiN architecture with different degrees of grouping per layer. Results are shown in \cref{fig:nincifarplotsconvonly}. The results show that the so-called root topology (illustrated in \cref{fig:networktopology}) gives the best performance, providing the smallest reduction in accuracy for a given reduction in model size and computational complexity. Similar experiments with deeper network architectures have delivered similar results and so we have reported results for root topologies. This aligns with the intuition of deep networks for image recognition subsuming the deformable parts model. If we assume that filter responses identify parts (or more elemental features), then there should be more filter dependence with depth, as more parts (filter responses) are assembled into complex concepts.
	
	\subsection{Improving Residual Networks on \gls{ilsvrc}}
	Residual networks (ResNets)~\citep{He2015} are the state-of-the art network for \gls{ilsvrc}\@. ResNets are more computationally efficient than the VGG architecture~\citep{Simonyan2014verydeep} on which they are based, due to the use of low-dimensional embeddings~\citep{Lin2013NiN}. ResNets are also more accurate and quicker to converge due to the use of identity mappings.
	
	\subsubsection{ResNet 50}
	\label{resnet50results}
	As a baseline, we used the `ResNet 50' model~\citep{He2015} (the largest residual network model to fit onto 8 \gls{gpu}s with Caffe). ResNet 50 has 50 convolutional layers, of which one-third are spatial convolutions (non-1$\times$1). We did not use any training augmentation aside from random cropping and mirroring. 
	For training, we used the initialization scheme described by~\citep{He2015b} modified for compound layers~\citep{Ioannou2016} and batch normalization~\citep{Ioffe2015}.
	\begin{table}[tp]
		\caption[ResNet 50 root architectures.]{\textbf{ResNet 50}. Filter groups in each conv.\ layer.}
		\label{table:resnet50config}
		\centering
		\begin{tabular}{@{}lcccccccccccc@{}}
			\toprule
			Model & conv1 & \multicolumn{2}{c}{res2\{a--c\}} & \multicolumn{2}{c}{res3\{a--d\}} & \multicolumn{2}{c}{res4\{a--f\}} & \multicolumn{2}{c}{res5\{a--c\}} \\
			& \textit{\footnotesize7$\times$7} & \textit{\footnotesize1$\times$1} & \textit{\footnotesize3$\times$3} & \textit{\footnotesize1$\times$1} & \textit{\footnotesize3$\times$3} & \textit{\footnotesize1$\times$1} & \textit{\footnotesize3$\times$3} & \textit{\footnotesize1$\times$1} & \textit{\footnotesize3$\times$3} \\
			Orig. & 1 & 1 & 1 & 1 &  1 & 1 &  1 & 1 & 1 \\
			\midrule
			root-2 & 1 & 1 & 2 & 1 &  1 & 1 &  1 & 1 & 1 \\
			root-4 & 1 & 1 & 4 & 1 &  2 & 1 &  1 & 1 & 1 \\
			root-8 & 1 & 1 & 8 & 1 &  4 & 1 &  2 & 1 & 1 \\
			root-16 & 1 & 1 & 16 & 1 &  8 & 1 &  4 & 1 & 2 \\
			root-32 & 1 & 1 & 32 & 1 & 16 & 1 &  8 & 1 & 4 \\
			root-64 & 1 & 1 & 64 & 1 & 32 & 1 & 16 & 1 & 8 \\
			\bottomrule
		\end{tabular}
	\end{table}
	To assess the efficacy of our method, we replaced the spatial convolutional layers of the original network with root modules (as described in \cref{method}). We preserved the original number of filters per layer but subdivided them into groups as shown in \cref{table:resnet50config}. We considered the first of the existing 1$\times$1 layers subsequent to each spatial convolution to be part of our root modules. 
	\begin{table}[tp]
		\caption[ResNet 50 \gls{ilsvrc} Results]{\textbf{ResNet 50 Results.}}
		\label{table:resnet50imagenetresults}
		%\resizebox{\textwidth}{!}{
		\centering
		\pgfplotstableread[col sep=comma]{rootdata/resnet50ma.csv}\data
		%\pgfplotstableread[col sep=comma]{rootdata/resnet50maall.csv}\alldata
		\pgfplotstableread[col sep=comma]{rootdata/resnet50maconvonly.csv}\codata
		%\pgfplotstablevertcat{\data}{\alldata}
		\pgfplotstablevertcat{\data}{\codata}
		\pgfplotstableset{
			create on use/singlegpu/.style={
				create col/expr={\thisrow{GPU Forward} / \thisrow{Batch Size}}},
		}
		\pgfplotstableset{
			create on use/singlecpu/.style={
				create col/expr={\thisrow{CPU Forward} / \thisrow{Batch Size}}},
		}
		\pgfplotstabletypeset[
		every head row/.style={
			before row=\toprule,after row=\midrule},
		every last row/.style={
			after row=\bottomrule},
		every first row/.style={
			after row=\midrule}, 
		fixed zerofill,     % Fill numbers with zeros
		columns={Full Name, Multiply-Acc., Param., Top-1 Acc., Top-5 Acc., singlecpu, singlegpu},
		columns/Full Name/.style={
			column name=Model,
			string type
		},
		columns/singlegpu/.style={
			column name=GPU (ms),
			precision=1
		},
		columns/singlecpu/.style={
			column name=\gls{cpu} (ms),
			precision=0
		},
		columns/Multiply-Acc./.style={
			column name=\gls{flops} {\small $\times 10^{9}$},
			preproc/expr={{##1/1e9}}
		},
		columns/Param./.style={
			column name=Param. {\small $\times 10^{7}$},
			preproc/expr={{##1/1e7}}
		},
		columns/Top-1 Acc./.style={precision=3},
		columns/Top-5 Acc./.style={precision=3},
		highlight col max ={\data}{Top-1 Acc.},
		highlight col max ={\data}{Top-5 Acc.}, 
		highlight col min ={\data}{Param.}, 
		highlight col min ={\data}{Multiply-Acc.}, 
		column type/.add={@{}lp{3em}p{3em}p{3em}p{3em}p{3em}p{3em}@{}}{},
		col sep=comma]{\data}
		%}
	\end{table}
	\begin{figure}[p]
		\centering
		\begin{subfigure}[b]{\textwidth}
			\pgfplotstableread[col sep=comma]{rootdata/resnet50ma.csv}\gdatatable
			\pgfplotstableread[col sep=comma]{rootdata/resnet50maconvonly.csv}\codatatable
			\pgfplotsset{major grid style={dotted,red}}
			
			\pgfplotstableset{
				create on use/singlecpu/.style={
					create col/expr={\thisrow{\gls{cpu} Forward} / \thisrow{Batch Size}}},
			}
			
			\centering
			\begin{tikzpicture}
			\begin{axis}[
			width=0.95\textwidth,
			height=0.24\textheight,
			axis x line=bottom,
			ylabel=Top-5 Error,
			xlabel=Model Parameters (\# Floats),
			axis lines=left,
			enlarge x limits=0.05,
			%enlarge y limits=0.1,
			grid=major,
			%xmin=0,
			ytick={0.01,0.02,...,0.2},
			ymin=0.07,ymax=0.1,
			xticklabel style={
				/pgf/number format/fixed,
				/pgf/number format/precision=3
			},
			yticklabel={\pgfmathparse{\tick*100}\pgfmathprintnumber{\pgfmathresult}\%},style={
				/pgf/number format/fixed,
				/pgf/number format/precision=1
			},
			legend style={at={(0.98,0.98)}, anchor=north east, column sep=0.5em},
			legend columns=3,
			]
			\addplot[mark=*,mark options={fill=red},
			%nodes near coords,
			only marks,
			point meta=explicit symbolic,
			] table[meta=Network,x=Param.,y expr={1 - \thisrow{Top-5 Acc.} },]{\gdatatable};
			\addplot[mark=square*,mark options={fill=green},
			nodes near coords, nodes near coords align = {below}, only marks,
			every node near coord/.append style={inner sep=4pt},
			only marks,
			point meta=explicit symbolic,
			] table[meta=Network,x=Param.,y expr={1 - \thisrow{Top-5 Acc.} },]{\codatatable};
			\legend{ResNet 50, All Filters, Spatial Filters, LDE Half}
			\end{axis}
			\end{tikzpicture}
			\caption{\textbf{Model Parameters \vs Top-5 Error.}}
			\label{fig:resnet5050param}
		\end{subfigure}
		~
		\begin{subfigure}[b]{\textwidth}
			\pgfplotstableread[col sep=comma]{rootdata/resnet50ma.csv}\gdatatable
			\pgfplotstableread[col sep=comma]{rootdata/resnet50maconvonly.csv}\codatatable
			\pgfplotsset{major grid style={dotted,red}}
			
			\centering
			\begin{tikzpicture}
			\begin{axis}[
			width=0.95\textwidth,
			height=0.24\textheight,
			axis x line=bottom,
			ylabel=Top-5 Error,
			xlabel=\gls{flops} (Multiply-Add),
			axis lines=left,
			enlarge x limits=0.05,
			%enlarge y limits=0.1,
			grid=major,
			%xmin=0,
			ytick={0.01,0.02,...,0.2},
			ymin=0.07,ymax=0.1,
			xticklabel style={
				/pgf/number format/fixed,
				/pgf/number format/precision=3
			},
			yticklabel={\pgfmathparse{\tick*100}\pgfmathprintnumber{\pgfmathresult}\%},style={
				/pgf/number format/fixed,
				/pgf/number format/precision=1
			},
			legend style={at={(0.98,0.98)}, anchor=north east, column sep=0.5em},
			legend columns=3,
			]
			\addplot[mark=*,mark options={fill=red},
			%nodes near coords,
			only marks,
			point meta=explicit symbolic,
			] table[meta=Network,x=Multiply-Acc.,y expr={1 - \thisrow{Top-5 Acc.} },]{\gdatatable};
			\addplot[mark=square*,mark options={fill=green},
			nodes near coords, nodes near coords align = {below}, only marks,
			every node near coord/.append style={inner sep=4pt},
			only marks,
			point meta=explicit symbolic,
			] table[meta=Network,x=Multiply-Acc.,y expr={1 - \thisrow{Top-5 Acc.} },]{\codatatable};
			\end{axis}
			\end{tikzpicture}
			\caption{\textbf{\gls{flops} (Multiply-Add) \vs Top-5 Error.}}
			\label{fig:resnet50ma}
		\end{subfigure}
		~
		\begin{subfigure}[b]{\textwidth}
			\pgfplotstableread[col sep=comma]{rootdata/resnet50ma.csv}\gdatatable
			\pgfplotstableread[col sep=comma]{rootdata/resnet50maconvonly.csv}\codatatable
			\pgfplotsset{major grid style={dotted,red}}
			
			\centering
			\begin{tikzpicture}
			\begin{axis}[
			width=0.95\textwidth,
			height=0.24\textheight,
			axis x line=bottom,
			ylabel=Top-5 Error,
			xlabel=\gls{gpu} Forward (ms),
			axis lines=left,
			enlarge x limits=0.05,
			%enlarge y limits=0.1,
			grid=major,
			%xmin=0,
			ytick={0.01,0.02,...,0.2},
			ymin=0.07,ymax=0.1,
			xticklabel style={
				/pgf/number format/fixed,
				/pgf/number format/precision=3
			},
			yticklabel={\pgfmathparse{\tick*100}\pgfmathprintnumber{\pgfmathresult}\%},style={
				/pgf/number format/fixed,
				/pgf/number format/precision=1
			},
			legend style={at={(0.98,0.98)}, anchor=north east, column sep=0.5em},
			legend columns=3,
			]
			\addplot[mark=*,mark options={fill=red},
			%nodes near coords,
			only marks,
			point meta=explicit symbolic,
			] table[meta=Network,
			x expr={\thisrow{GPU Forward} / \thisrow{Batch Size}},
			y expr={1 - \thisrow{Top-5 Acc.} }
			]{\gdatatable};
			\addplot[mark=square*,mark options={fill=green},
			nodes near coords, nodes near coords align = {below}, only marks,
			every node near coord/.append style={inner sep=4pt},
			only marks,
			point meta=explicit symbolic,
			] table[meta=Network,
			x expr={\thisrow{GPU Forward} / \thisrow{Batch Size}},
			y expr={1 - \thisrow{Top-5 Acc.} },
			]{\codatatable};
			%\legend{ResNet 50, All Filters, Spatial Filters}
			\end{axis}
			\end{tikzpicture}
			\caption{\textbf{\gls{gpu} Forward Time \vs Top-5 Error.}}
			\label{fig:resnet5050gpuforward}
		\end{subfigure}
		~
		\begin{subfigure}[b]{\textwidth}
			\pgfplotstableread[col sep=comma]{rootdata/resnet50ma.csv}\gdatatable
			\pgfplotstableread[col sep=comma]{rootdata/resnet50maconvonly.csv}\codatatable
			\pgfplotsset{major grid style={dotted,red}}
			
			\centering
			\begin{tikzpicture}
			\begin{axis}[
			width=0.95\textwidth,
			height=0.24\textheight,
			axis x line=bottom,
			ylabel=Top-5 Error,
			xlabel=\gls{cpu} Forward (ms),
			axis lines=left,
			enlarge x limits=0.05,
			%enlarge y limits=0.1,
			grid=major,
			%xmin=0,
			ytick={0.01,0.02,...,0.2},
			ymin=0.07,ymax=0.1,
			xticklabel style={
				/pgf/number format/fixed,
				/pgf/number format/precision=3
			},
			yticklabel={\pgfmathparse{\tick*100}\pgfmathprintnumber{\pgfmathresult}\%},style={
				/pgf/number format/fixed,
				/pgf/number format/precision=1
			},
			legend style={at={(0.98,0.98)}, anchor=north east, column sep=0.5em},
			legend columns=3,
			]
			\addplot[mark=*,mark options={fill=red},
			%nodes near coords,
			only marks,
			point meta=explicit symbolic,
			] table[meta=Network,
			x expr={\thisrow{CPU Forward} / \thisrow{Batch Size}},
			y expr={1 - \thisrow{Top-5 Acc.} },
			]{\gdatatable};
			\addplot[mark=square*,mark options={fill=green},
			nodes near coords, nodes near coords align = {below}, only marks,
			every node near coord/.append style={inner sep=4pt},
			only marks,
			point meta=explicit symbolic,
			] table[meta=Network,
			x expr={\thisrow{CPU Forward} / \thisrow{Batch Size}},
			y expr={1 - \thisrow{Top-5 Acc.} },
			]{\codatatable};
			%\legend{ResNet 50, All Filters, Spatial Filters}
			\end{axis}
			\end{tikzpicture}
			\caption{\textbf{CPU Forward Time \vs Top-5 Error.}}
			\label{fig:resnet5050cpuforward}
		\end{subfigure}
		
		\caption[ResNet-50 \gls{ilsvrc} results.]{\textbf{ResNet-50 \gls{ilsvrc} Results.} Models with filter groups have fewer parameters, and less floating point operations, while maintaining error comparable to the baseline.}
		\label{fig:resnet50plots}
	\end{figure}
	Results are shown in \cref{table:resnet50imagenetresults} and \cref{fig:resnet50plots} for various network architectures. Compared to the baseline architecture, the root variants achieve a significant reduction in computation and model size without a significant reduction in accuracy. For example, the best result (root-16) exceeds the baseline accuracy by 0.2\% while reducing the model size by 27\% and floating-point operations (multiply-add) by 37\%. \gls{cpu} timings were 23\% faster, while \gls{gpu} timings were 13\% faster. With a drop in accuracy of only 0.1\% however, the root-64 model reduces the model size by 40\%, and reduces the floating point operations by 45\%. \gls{cpu} timings were 31\% faster, while \gls{gpu} timings were 12\% faster. 
	
	\subsubsection{ResNet 200}
	\label{resnet200results}
	\begin{table}[tp]
		\caption[ResNet 200 \gls{ilsvrc} results.]{\textbf{ResNet-200 \gls{ilsvrc} Results}}
		\label{table:resnet200imagenetresults}
		%\resizebox{\columnwidth}{!}{
		\centering
		\pgfplotstableread[col sep=comma]{rootdata/resnet200.csv}\data
		\pgfplotstabletypeset[
		every head row/.style={
			before row=\toprule,after row=\midrule},
		every last row/.style={
			after row=\bottomrule},
		every first row/.style={
			after row=\midrule}, 
		columns={full name, ma, param, top1, top5},
		columns/full name/.style={
			column name=Model,
			string type
		},
		columns/ma/.style={
			column name=\gls{flops}~{\small$\times 10^{12}$},
			fixed zerofill,
			preproc/expr={{##1/1e12}},
		},
		columns/param/.style={
			column name=Param.~{\small$\times 10^{7}$},
			fixed zerofill,
			preproc/expr={{##1/1e7}},
		},
		columns/top1/.style={
			precision=4,
			column name=Top-1 Err.,
			fixed zerofill,
		},
		columns/top5/.style={
			precision=4,
			column name=Top-5 Err.,
			fixed zerofill,
		},
		column type/.add={@{}lrrrrrr@{}}{},
		highlight col min ={\data}{top1},
		highlight col min ={\data}{top5}, 
		highlight col min ={\data}{param}, 
		highlight col min ={\data}{ma}, 
		col sep=comma]{\data}
		%}
	\end{table}
	To show that the method applies to deeper architectures, we also applied our method to ResNet 200, the deepest network for \gls{ilsvrc} 2012. To provide a baseline we used code implementing full training augmentation to achieve state-of-the-art results\footnote{\url{https://github.com/facebook/fb.resnet.torch}}. \cref{table:resnet200imagenetresults} shows the results of these experiments, top-1 and top-5 error are for center cropped images. The models trained with roots have comparable error to the baseline network, with fewer parameters and less computation. The root-32 model has 25\% fewer \gls{flops} and 44\% fewer parameters than ResNet 200.
	
	\subsection{Improving GoogLeNet on \gls{ilsvrc}}
	\label{googlenet50results}
	\begin{table}[tp]
		\caption[GoogLeNet \gls{ilsvrc} results.]{\textbf{GoogLeNet \gls{ilsvrc} Results.}}
		\label{table:googlenetimagenetresults}
		%\resizebox{\columnwidth}{!}{
		\centering
		\pgfplotstableread[col sep=comma]{rootdata/googlenetma.csv}\data
		\pgfplotstableread[col sep=comma]{rootdata/googlenetmaconvonly.csv}\codata
		\pgfplotstablevertcat{\data}{\codata}
		\pgfplotstableset{
			create on use/singlegpu/.style={
				create col/expr={\thisrow{GPU Forward} / \thisrow{Batch Size}}},
		}
		\pgfplotstableset{
			create on use/singlecpu/.style={
				create col/expr={\thisrow{CPU Forward} / \thisrow{Batch Size}}},
		}
		\pgfplotstabletypeset[
		every head row/.style={
			before row=\toprule,after row=\midrule},
		every last row/.style={
			after row=\bottomrule},
		every first row/.style={
			after row=\midrule}, 
		fixed zerofill,     % Fill numbers with zeros
		columns={Full Name, Multiply-Acc., Param., Top-1 Acc., Top-5 Acc., singlecpu, singlegpu},
		columns/Full Name/.style={
			column name=Model,
			string type
		},
		columns/singlegpu/.style={
			column name=\gls{gpu} (ms),
			precision=2
		},
		columns/singlecpu/.style={
			column name=\gls{cpu} (ms),
			precision=0
		},
		columns/Multiply-Acc./.style={
			column name=\gls{flops} {\small $\times 10^{9}$},
			preproc/expr={{##1/1e9}}
		},
		columns/Param./.style={
			column name=Param. {\small $\times 10^{7}$},
			preproc/expr={{##1/1e7}}
		},
		columns/Top-1 Acc./.style={precision=3},
		columns/Top-5 Acc./.style={precision=3},
		highlight col max ={\data}{Top-1 Acc.},
		highlight col max ={\data}{Top-5 Acc.}, 
		highlight col min ={\data}{Param.}, 
		highlight col min ={\data}{Multiply-Acc.}, 
		%    column type/.add={@{}lrrrrrr@{}}{},
		column type/.add={@{}lp{3em}p{3em}p{3em}p{3em}p{3em}p{3em}@{}}{},
		col sep=comma]{\data}
		%}
	\end{table}
	
	\begin{table}[tp]
		\caption[GoogLeNet root architectures.]{\textbf{GoogLeNet}. Filter groups in each convolutional layer and Inception module (\textit{incp}.)}
		\label{table:googlenetconfig}
		\centering
		\begin{tabular}{@{}lcccccccccccc@{}}
			\toprule
			Model & conv1 & \multicolumn{2}{c}{conv2} & \multicolumn{3}{c}{incp.~3\{a,b\}} & \multicolumn{3}{c}{incp.~4\{a--e\}} & \multicolumn{3}{c}{incp.~5\{a,b\}} \\
			& \textit{\footnotesize7$\times$7} & \textit{\footnotesize1$\times$1} & \textit{\footnotesize3$\times$3} & \textit{\footnotesize1$\times$1} & \textit{\footnotesize3$\times$3} & \textit{\footnotesize5$\times$5} & \textit{\footnotesize1$\times$1} & \textit{\footnotesize3$\times$3} & \textit{\footnotesize5$\times$5} & \textit{\footnotesize1$\times$1} & \textit{\footnotesize3$\times$3} & \textit{\footnotesize5$\times$5} \\
			Orig. & 1 &  1 &  1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1\\ 
			\midrule
			root-2 & 1 &  1 &  2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1\\
			root-4 & 1 &  1 &  4 & 1 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1\\
			root-8 & 1 &  1 &  8 & 1 & 4 & 4 & 1 & 2 & 2 & 1 & 1 & 1\\
			root-16 & 1 &  1 & 16 & 1 & 8 & 8 & 1 & 4 & 4 & 1 & 2 & 2\\
			\bottomrule
		\end{tabular}
	\end{table}
	
	We replicated the network as described by \citet{Szegedy2014going}, with the exception of not using any training augmentation aside from random crops and mirroring (as supported by Caffe~\citep{Jia2014}). To train we used the initialization of~\citep{He2015b} modified for compound layers~\citep{Ioannou2016} and batch normalization without the scale and bias~\citep{Ioffe2015}. At test time we only evaluate the center crop image.
	
	While preserving the original number of filters per layer, we trained networks with various degrees of filter grouping, as described in \cref{table:googlenetconfig}.  While the inception architecture is relatively complex, for simplicity, we always use the same number of groups within each of the groups of different filter sizes, despite them having different cardinality. For all of the networks, we only grouped filters within each of the `spatial' convolutions (3$\times$3, 5$\times$5).
	\begin{figure}[p]
		\centering
		\begin{subfigure}[b]{\textwidth}
			\pgfplotstableread[col sep=comma]{rootdata/googlenetma.csv}\gdatatable
			\pgfplotstableread[col sep=comma]{rootdata/googlenetmaconvonly.csv}\codatatable
			\pgfplotsset{major grid style={dotted,red}}
			
			\centering
			\begin{tikzpicture}
			\begin{axis}[
			width=0.95\textwidth,
			height=0.24\textheight,
			axis x line=bottom,
			ylabel=Top-5 Error,
			xlabel=Model Parameters (\# Floats),
			axis lines=left,
			enlarge x limits=0.05,
			grid=major,
			%xmin=0,
			ytick={0.01,0.02,...,0.2},
			ymin=0.095,ymax=0.125,
			xticklabel style={
				/pgf/number format/fixed,
				/pgf/number format/precision=3
			},
			yticklabel={\pgfmathparse{\tick*100}\pgfmathprintnumber{\pgfmathresult}\%},style={
				/pgf/number format/fixed,
				/pgf/number format/precision=1
			},
			legend style={at={(0.98,0.98)}, anchor=north east, column sep=0.5em},
			legend columns=3,
			]
			\addplot[mark=*,mark options={fill=red},
			%nodes near coords,
			only marks,
			point meta=explicit symbolic,
			] table[meta=Network,x=Param.,y expr={1 - \thisrow{Top-5 Acc.} },]{\gdatatable};
			\addplot[mark=square*,mark options={fill=green},
			nodes near coords, nodes near coords align = {below}, only marks,
			every node near coord/.append style={inner sep=4pt},
			only marks,
			point meta=explicit symbolic,
			] table[meta=Network,x=Param.,y expr={1 - \thisrow{Top-5 Acc.} },]{\codatatable};
			\legend{GoogLeNet, All Filters, Spatial Filters}
			\end{axis}
			\end{tikzpicture}
			\caption{\textbf{Model Parameters \vs Top-5 Error.}}
			\label{fig:googlenet50param}
		\end{subfigure}
		~
		\begin{subfigure}[b]{\textwidth}
			\pgfplotstableread[col sep=comma]{rootdata/googlenetma.csv}\gdatatable
			\pgfplotstableread[col sep=comma]{rootdata/googlenetmaconvonly.csv}\codatatable
			\pgfplotsset{major grid style={dotted,red}}
			
			\centering
			\begin{tikzpicture}
			\begin{axis}[
			width=0.95\textwidth,
			height=0.24\textheight,
			axis x line=bottom,
			ylabel=Top-5 Error,
			xlabel=\gls{flops} (Multiply-Add),
			axis lines=left,
			enlarge x limits=0.05,
			grid=major,
			%xmin=0,
			ytick={0.01,0.02,...,0.2},
			ymin=0.095,ymax=0.125,
			xticklabel style={
				/pgf/number format/fixed,
				/pgf/number format/precision=3
			},
			yticklabel={\pgfmathparse{\tick*100}\pgfmathprintnumber{\pgfmathresult}\%},style={
				/pgf/number format/fixed,
				/pgf/number format/precision=1
			},
			legend style={at={(0.98,0.98)}, anchor=north east, column sep=0.5em},
			legend columns=3,
			]
			\addplot[mark=*,mark options={fill=red},
			%nodes near coords,
			only marks,
			point meta=explicit symbolic,
			] table[meta=Network,x=Multiply-Acc.,y expr={1 - \thisrow{Top-5 Acc.} },]{\gdatatable};
			\addplot[mark=square*,mark options={fill=green},
			nodes near coords, nodes near coords align = {below}, only marks,
			every node near coord/.append style={inner sep=4pt},
			only marks,
			point meta=explicit symbolic,
			] table[meta=Network,x=Multiply-Acc.,y expr={1 - \thisrow{Top-5 Acc.} },]{\codatatable};
			%\legend{GoogLeNet, All Filters, Spatial Filters}
			\end{axis}
			\end{tikzpicture}
			\caption{\textbf{\gls{flops} (Multiply-Add) \vs Top-5 Error.}}
			\label{fig:googlenet50ma}
		\end{subfigure}
		~
		\begin{subfigure}[b]{\textwidth}
			\pgfplotstableread[col sep=comma]{rootdata/googlenetma.csv}\gdatatable
			\pgfplotstableread[col sep=comma]{rootdata/googlenetmaconvonly.csv}\codatatable
			\pgfplotsset{major grid style={dotted,red}}
			
			\centering
			\begin{tikzpicture}
			\begin{axis}[
			width=0.95\textwidth,
			height=0.24\textheight,
			axis x line=bottom,
			ylabel=Top-5 Error,
			xlabel=\gls{gpu} Forward (ms),
			axis lines=left,
			enlarge x limits=0.05,
			grid=major,
			%xmin=0,
			ytick={0.01,0.02,...,0.2},
			ymin=0.095,ymax=0.125,
			xticklabel style={
				/pgf/number format/fixed,
				/pgf/number format/precision=3
			},
			yticklabel={\pgfmathparse{\tick*100}\pgfmathprintnumber{\pgfmathresult}\%},style={
				/pgf/number format/fixed,
				/pgf/number format/precision=1
			},
			legend style={at={(0.98,0.98)}, anchor=north east, column sep=0.5em},
			legend columns=3,
			]
			\addplot[mark=*,mark options={fill=red},
			%nodes near coords,
			only marks,
			point meta=explicit symbolic,
			] table[meta=Network,
			x expr={\thisrow{GPU Forward} / \thisrow{Batch Size}},
			y expr={1 - \thisrow{Top-5 Acc.} },]{\gdatatable};
			\addplot[mark=square*,mark options={fill=green},
			nodes near coords, nodes near coords align = {below}, only marks,
			every node near coord/.append style={inner sep=4pt},
			only marks,
			point meta=explicit symbolic,
			] table[meta=Network,
			x expr={\thisrow{GPU Forward} / \thisrow{Batch Size}},
			y expr={1 - \thisrow{Top-5 Acc.} },]{\codatatable};
			%\legend{GoogLeNet, All Filters, Spatial Filters}
			\end{axis}
			\end{tikzpicture}
			\caption{\textbf{\gls{gpu} Forward Time \vs Top-5 Error.}}
			\label{fig:googlenet50gpuforward}
		\end{subfigure}
		~
		\begin{subfigure}[b]{\textwidth}
			\pgfplotstableread[col sep=comma]{rootdata/googlenetma.csv}\gdatatable
			\pgfplotstableread[col sep=comma]{rootdata/googlenetmaconvonly.csv}\codatatable
			\pgfplotsset{major grid style={dotted,red}}
			
			\centering
			\begin{tikzpicture}
			\begin{axis}[
			width=0.95\textwidth,
			height=0.24\textheight,
			axis x line=bottom,
			ylabel=Top-5 Error,
			xlabel=\gls{cpu} Forward (ms),
			axis lines=left,
			enlarge x limits=0.05,
			grid=major,
			%xmin=0,
			ytick={0.01,0.02,...,0.2},
			ymin=0.095,ymax=0.125,
			xticklabel style={
				/pgf/number format/fixed,
				/pgf/number format/precision=3
			},
			yticklabel={\pgfmathparse{\tick*100}\pgfmathprintnumber{\pgfmathresult}\%},style={
				/pgf/number format/fixed,
				/pgf/number format/precision=1
			},
			legend style={at={(0.98,0.98)}, anchor=north east, column sep=0.5em},
			legend columns=3,
			]
			\addplot[mark=*,mark options={fill=red},
			%nodes near coords,
			only marks,
			point meta=explicit symbolic,
			] table[meta=Network,
			x expr={\thisrow{CPU Forward} / \thisrow{Batch Size}},
			y expr={1 - \thisrow{Top-5 Acc.} },]{\gdatatable};
			\addplot[mark=square*,mark options={fill=green},
			nodes near coords, nodes near coords align = {below}, only marks,
			every node near coord/.append style={inner sep=4pt},
			only marks,
			point meta=explicit symbolic,
			] table[meta=Network,
			x expr={\thisrow{CPU Forward} / \thisrow{Batch Size}},
			y expr={1 - \thisrow{Top-5 Acc.} },]{\codatatable};
			%\legend{GoogLeNet, All Filters, Spatial Filters}
			\end{axis}
			\end{tikzpicture}
			\caption{\textbf{\gls{cpu} Forward Time \vs Top-5 Error.}}
			\label{fig:googlenet50cpuforward}
		\end{subfigure}
		
		\caption[GoogLeNet \gls{ilsvrc} results.]{\textbf{GoogLeNet \gls{ilsvrc} Results.} Models with filter groups have fewer parameters, and less floating point operations, while maintaining error comparable to the baseline.}
		\label{fig:googlenet50plots}
	\end{figure}
	
	As shown in \cref{table:googlenetimagenetresults}, and plotted in \cref{fig:googlenet50plots}, our method shows significant reduction in computational complexity -- as measured in \gls{flops} (multiply-adds), \gls{cpu} and \gls{gpu} timings -- and model size, as measured in the number of floating point parameters. For many of the configurations the top-5 accuracy remains within 0.5\% of the baseline model. 
	The highest accuracy result, is 0.1\% off the top-5 accuracy of the baseline model, but has a 0.1\% higher top-1 accuracy -- within the error bounds resulting from training with different random initializations. While maintaining the same accuracy, this network has 9\% faster \gls{cpu} and \gls{gpu} timings. However, a model with only 0.3\% lower top-5 accuracy than the baseline has much higher gains in computational efficiency -- 44\% fewer floating point operations (multiply-add), 7\% fewer model parameters, 21\% faster \gls{cpu} and 16\% faster \gls{gpu} timings.
	
	While these results may seem modest compared to the results for ResNet, GoogLeNet is by far the smallest and fastest near state-of-the-art model \gls{ilsvrc} model. We believe that more experimentation in using different cardinalities of filter grouping in the heterogeneously-sized filter groups within each inception module will improve results further.
	
	\section{\gls{gpu} Implementation}
	\label{gpuexplanation}
	%\subsection{\gls{gpu} Implementation.}
	Our experiments show that our method can achieve a significant reduction in \gls{cpu} and \gls{gpu} runtimes for state-of-the-art \glspl{cnn} without compromising accuracy. However, the reductions in \gls{gpu} runtime were smaller than might have been expected based on theoretical predictions of computational complexity (FLOPs). We believe this is largely a consequence of the optimization of Caffe for existing network architectures (particularly AlexNet and GoogLeNet) that do not use a high degree of filter grouping.
	
	Caffe presently parallelizes over filter groups by using multiple \gls{cuda} streams to run multiple \gls{cublas} matrix multiplications simultaneously. However, with a large degree of filter grouping, and hence more, smaller matrix multiplications, the overhead associated with calling \gls{cublas} from the host can take approximately as long as the matrix computation itself. To avoid this overhead, \gls{cublas} provides batched methods (\eg \texttt{cublasXgemmBatched}), where many small matrix multiplications can be batched together in one call. \citet{Jhurani2015} explore in depth the problem of using \gls{gpu}s to accelerate the multiplication of very small matrices (smaller than 16$\times$16), and show it is possible to achieve high throughput with large batches, by implementing a more efficient interface than that used in the \gls{cublas} batched calls.
	We have modified Caffe to use \gls{cublas} batched calls, and achieved significant speedups for our  root-like network architectures compared to vanilla Caffe without CuDNN, e.g. a 25\%\ speed up on our root-16 modified version of the GoogleNet architecture. However, our optimized implementation still is not as fast as Caffe with CuDNN (which was used to generate the results in this paper), presumably because of other unrelated optimizations in the (proprietary) CuDNN library. Therefore we suggest that direct integration of \gls{cublas}-style batching into CuDNN could improve the performance of filter groups significantly.
	
	\subsection{The Effect on Image-level Filters of Root Modules}
	\begin{figure}[tb]
		\centering
		\begin{subfigure}[b]{0.45\textwidth}
			\centering
			\includegraphics[width=\textwidth]{Figs/Raster/msrc-resnet-50-conv1}
			\caption{Standard}
			\label{fig:resnet50normalconv0}
		\end{subfigure}
		~
		\begin{subfigure}[b]{0.45\textwidth}
			\centering
			\includegraphics[width=\textwidth]{Figs/Raster/msrc-resnet-50-conv1-root4-convonly}
			\caption{Root-2}
			\label{fig:resnet50root2conv0}
		\end{subfigure}
		~
		\begin{subfigure}[b]{0.45\textwidth}
			\centering
			\includegraphics[width=\textwidth]{Figs/Raster/msrc-resnet-50-conv1-root8-convonly}
			\caption{Root-4}
			\label{fig:resnet50root4conv0}
		\end{subfigure}
		~
		\begin{subfigure}[b]{0.45\textwidth}
			\centering
			\includegraphics[width=\textwidth]{Figs/Raster/msrc-resnet-50-conv1-root16-convonly}
			\caption{Root-8}
			\label{fig:resnet50root8conv0}
		\end{subfigure}
		~
		\begin{subfigure}[b]{0.45\textwidth}
			\centering
			\includegraphics[width=\textwidth]{Figs/Raster/msrc-resnet-50-conv1-root32-convonly}
			\caption{Root-16}
			\label{fig:resnet50root16conv0}
		\end{subfigure}
		~
		\begin{subfigure}[b]{0.45\textwidth}
			\centering
			\includegraphics[width=\textwidth]{Figs/Raster/msrc-resnet-50-conv1-root64-convonly}
			\caption{Root-32}
			\label{fig:resnet50root32conv0}
		\end{subfigure}
		\caption[ResNet 50 conv1 filters.]{\textbf{ResNet 50 \texttt{conv1} filters.} With filter groups directly after \texttt{conv1}, in \texttt{conv2}, some of the organization of filters can be directly observed, and give us intuition as to what is happening in root networks.}
		\label{fig:resnet50conv0}
	\end{figure}
	In the ResNet root models, filter groups are used in \texttt{conv2},  directly after the image level filters of \texttt{conv1} some of the organization of filters can be directly observed, and give us intuition as to what is happening in root networks. \Cref{fig:resnet50conv0} shows the \texttt{conv0} filters learned for each of the ResNet 50 models. It is apparent that the filters learned in these networks are very similar to those learned in the original model, although sometimes inverted or with a different ordering. This ordering is somewhat consistent in models with filter groups however, even with different random initializations. This is because filter groups cause filters with strong mutual information to be grouped adjacent to each other.
	
	For example, in the root-8 network (\cref{fig:resnet50root8conv0}), each row of filters corresponds to the input of an independent filter group in \texttt{conv2}. We can see that the first row primarily is composed of filters giving various directions of the same color gradient. These filters can be combined in the next layer to produce color edges easily. Due to the shortcut layer and the learned combinations of filters however, not all filter groupings are so obvious.
	
	\subsection{Layer-wise Compute/Parameter Savings}
	\afterpage{
	\begin{landscape}
	\begin{figure}[tbp]
		\centering
		\begin{subfigure}[b]{0.97\linewidth}
			
			\pgfplotstableread[col sep=comma]{rootdata/resnet50-layerma.csv}\datatable
			\pgfplotstableread[col sep=comma]{rootdata/resnet50-root64-layerma.csv}\datatablea
			\begin{tikzpicture}
			\begin{axis}[
			axis x line=bottom,
			axis y line=left,
			ybar=0pt,
			bar width=0.3em,
			width=0.95\linewidth,
			height=0.4\textheight,
			enlarge x limits=0.02,
			ylabel=\gls{flops},
			y label style={at={(axis description cs:-0.04,.5)},anchor=south},
			y tick label style={
				/pgf/number format/.cd,
				fixed,
				fixed zerofill,
				precision=1,
				/tikz/.cd
			},
			ymin=0,
			xmajorticks=false,
			legend style={at={(0.5,1.2)},
				draw=none, anchor=north,legend columns=-1},
			area legend,
			]
			\addplot[ybar, draw=none, fill=red!40] table [x expr=\coordindex,y=MA]{\datatable};
			\addplot[ybar, draw=none, fill=blue!40] table [x expr=\coordindex,y=MA]{\datatablea};
			\legend{ResNet 50, Root-64};
			\end{axis}
			\end{tikzpicture}
			
		\end{subfigure}
		
		\begin{subfigure}[b]{0.97\linewidth}
			
			\pgfplotstableread[col sep=comma]{rootdata/resnet50-layerparam.csv}\datatable
			\pgfplotstableread[col sep=comma]{rootdata/resnet50-root64-layerparam.csv}\datatablea
			\begin{tikzpicture}
			\begin{axis}[
			axis x line=bottom,
			axis y line=left,
			ybar=0pt,
			bar width=0.3em,
			width=0.95\linewidth,
			height=0.4\textheight,
			enlarge x limits=0.02,
			ylabel=Parameters,
			y label style={at={(axis description cs:-0.04,.5)},anchor=south},
			y tick label style={
				/pgf/number format/.cd,
				fixed,
				fixed zerofill,
				precision=1,
				/tikz/.cd
			},
			ymin=0,
			xticklabels from table={\datatable}{layer},
			xticklabel style = {rotate = 90, xshift = -0.8ex, anchor = mid east, font=\footnotesize},
			xtick=data,
			]
			\addplot[ybar, draw=none, fill=red!40] table [x expr=\coordindex,y=param]{\datatable};
			\addplot[ybar, draw=none, fill=blue!40] table [x expr=\coordindex,y=param]{\datatablea};
			\end{axis}
			\end{tikzpicture}
			
		\end{subfigure}
		\caption[ResNet 50 layer-wise \gls{flops}/parameters.]{\textbf{ResNet 50 Layer-wise \gls{flops}/Parameters.} 
		}
		
		\label{fig:resnet50layerwisema}
	\end{figure}
	\end{landscape}
	}
	\Cref{fig:resnet50layerwisema} shows the difference in compute and parameters for each layer in a standard ResNet-50 model and a root-64 variant. The layers in the original networks with the highest computational complexity are clearly the spatial convolutional layers, \ie layers with 3$\times$3 spatial filters. When instead a root-module is used, the computational complexity of these layers is reduced dramatically. While the low dimensional embedding layers (1$\times$1) are not changed, these have less than half the compute of the spatial convolution layers. The number of parameters in spatial convolution layers with large numbers of input channels, which increase towards the end of the network, are similarly reduced.
	
	\section{Discussion}
	We explored the effect of using complex hierarchical arrangements of filter groups in \glspl{cnn} and show that imposing a structured decrease in the degree of filter grouping with depth --- a `root' (inverse tree) topology --- can allow us to obtain more efficient variants of state-of-the-art networks without compromising accuracy. Our method appears to be complementary to existing methods, such as low-dimensional embeddings, and can be used more efficiently to train deep networks than methods that only approximate a pre-trained model's weights.
	
	We validated our method by using it to create more efficient variants of state-of-the-art \gls{nin}, Googlenet, and ResNet architectures, which were evaluated on the \gls{cifar10} and \gls{ilsvrc} datasets. Our results show comparable accuracy with the baseline architecture with fewer parameters and much less compute (as measured by \gls{cpu} and \gls{gpu} timings). For \gls{nin} on \gls{cifar10}, our model has 47\% of the parameters of the original network, and approximately 22\% faster \gls{cpu} and \gls{gpu} timings. For ResNet 50, our model has 27\% fewer parameters, and was 24\% (11\%) faster on a \gls{cpu} (\gls{gpu}). 
	%For ResNet 200 our model has 25\% fewer \gls{flops} and 44\% fewer parameters.
	Even for the most efficient of the near state-of-the-art \gls{ilsvrc} network, GoogLeNet, our model uses 7\% fewer parameters and is 21\% (16\%) faster on a \gls{cpu} (\gls{gpu}).
	\mynote{Update with newer resnet-200 results}
	
	
\end{document}
